# *** коллекции (контейнеры) ***

# список (list)

# создание пустого спска
my_list = []
my__list = list()

# добавление объекта (элемента) а список
my_list.append(100)
my_list.append(3.14)
my_list.append('hello')
my_list.append([10, 20, 30])

#print(my_list)

# чтение значений элемента 
# в квадратную кобочку указываем индекс
el = my_list[3]
el = my_list[3] [1]

#обратная  индексация

el = my_list[-1]

# замена значения элемента
my_list[0] = 2000


# удаление элемента по значению
# my_list.remove(3.14)

# удаление элемента по индексу
del my_list[-1]

# срез списка
s = 'hello, World'
my_list = list(s)

#срез с 2 индекса до конца исходного списка 
my_slice = my_list[2:]
# срез со второго индекса до 5-го индекса не включительно 
my_slice = my_list[2:5]
# срез с наала до 5-го индекса не включительно 
my_slice = my_list[:5]


# срез с 2-го индекса до 12-го не включительно
# с шагом 2 
my_slice = my_list[2:12:5]

#срез с применение обратной индексации 
#my_slice = my_list[-2:5]
my_slice = my_list[-2:-5:-1]

#переворост списка 
my_slice = my_list[::-1]
# len () возвращает длину (кол-во элементов) коллекции 
#print(len(my_list))
#print(my_list)
#print(my_slice)

# *** кортеж (tuple) ***

# неизменяемая (immutable) коллеция
# легковеснее, чем список

# создание кортежа

my_tuple = (10, 20 ,30 ,40, 50)

#ошибку выдаеет ! так невозможно
#my_tuple[0] = 100

#print(my_tuple)

# чтение значения элементов кортежей
#print(my_tuple[0])

#срез
#print(my_tuple[2:])


# **** словарь (dict) ***

# изменяемый, упорядоченный тип коллекции 

# пара "ключ-значения" 
# {ключ_1:значение_1, ключч_2:значение_2}

# создагние словоря 
my_dict = {10:3.14, 'abc':[1,2,3]}

#print(my_dict)

# чтение значений (данных)
#print(my_dict[10])
#print(my_dict['abc'])

data0 = {'name': "Mariya", 'age':24, 'id':123.5}
data1 = {'name': 'Janna', 'age':25, 'id':124.5}
data2 = {'name': 'Rita', 'age':26, 'id':127.56}

total_data = {'p0':data0, 'p1':data1, 'p2':data2}

#print(total_data['p1'] ['name'])
#print(total_data['p2'] ['id'])

#изменение значчений
my_dict['abc'] = 'hello'


# добавление новой пары 
#при присвоении нового значения по несуществующему ключу
# создается новая пара 
my_dict['A'] = 777

# удаление элемента (пары)
del my_dict['A']

# обновление данных

data1 = {'name': 'Janna', 'age':25, 'id':124.5}

data1.update({'age':26, 'id': 128.28, 'nickname': 'deffochka'})

#print(data1)


# **** множество (set) ***

# изменяемый тип коллекций

# особенности:
# - неупорядоченный тип коллекций (объекты находятся в беспорядке, т.е. не индексируются) 
# - автоматом удаляет дублирующие объекты

# создание пустого множества 
my_set = {10, 20, 30}

# добавление элемента 
my_set.add(123)

#когда добавляется значение, которое уже во множество, то оно не добавляется
my_set.add(30)

# удаление элемениа 
my_set.remove(20)
#my_set.remove(87)

# метод удаление без ошибок 
my_set.discard(123)

# дано два множеств 
w = {'a', 'b', 'c', 'd'}
z = {'b', 'c', 'r'}

# объединение множеств (кстати списки тоже можно знаком +)
f = w.union(z)
#или 
f = w | z 

#пересечение 
f = w.intersection(z)
# или
f = w & z

# разность
#зависит от переменной каака первая стоит, то и выдает 
f = z.difference(w)
f = w.difference(z)
# короткая запись дифференс
f = w - z 
f = z - w
#есть симметричная разность в обеих строках
f = w.symmetric_difference(z)
# самостоятельно поэкспериментировать с оставшимися методами

#print(f)

